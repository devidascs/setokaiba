{
  "version": 3,
  "file": "app.js",
  "sources": [
    "src/app.js",
    "src/directives/form-helpers.js",
    "src/error/error.js",
    "src/grandfather.js",
    "src/home/home.js",
    "src/login-service.js",
    "src/mockhttp.js",
    "src/pages/pages.js",
    "src/register/register.js",
    "src/routing-config.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC5MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC3KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A",
  "sourcesContent": [
    "angular.module('angular-login', [\r\n  // login service\r\n  'loginService',\r\n  'angular-login.mock',\r\n  'angular-login.directives',\r\n  // different app sections\r\n  'angular-login.home',\r\n  'angular-login.pages',\r\n  'angular-login.register',\r\n  'angular-login.error',\r\n  // components\r\n  'ngAnimate'\r\n])\r\n.config(function ($urlRouterProvider) {\r\n  $urlRouterProvider.otherwise('/');\r\n})\r\n.run(function ($rootScope, $window) {\r\n  // google analytics\r\n  $rootScope.$on('$stateChangeSuccess', function (event, toState, toParams) {\r\n    var realURL = toState.url;\r\n    if (!!$window.ga) {\r\n      // resolves variables inside urls, ex: /error/:error in /error/unauthorized\r\n      for (var v in toParams) {\r\n        realURL = realURL.replace(':' + v, toParams[v]);\r\n      }\r\n      $window.ga('send', 'pageview', realURL);\r\n    }\r\n  });\r\n  /**\r\n   * $rootScope.doingResolve is a flag useful to display a spinner on changing states.\r\n   * Some states may require remote data so it will take awhile to load.\r\n   */\r\n  var resolveDone = function () { $rootScope.doingResolve = false; };\r\n  $rootScope.doingResolve = false;\r\n\r\n  $rootScope.$on('$stateChangeStart', function () {\r\n    $rootScope.doingResolve = true;\r\n  });\r\n  $rootScope.$on('$stateChangeSuccess', resolveDone);\r\n  $rootScope.$on('$stateChangeError', resolveDone);\r\n  $rootScope.$on('$statePermissionError', resolveDone);\r\n})\r\n.controller('BodyController', function ($scope, $state, $stateParams, loginService, $http, $timeout) {\r\n  // Expose $state and $stateParams to the <body> tag\r\n  $scope.$state = $state;\r\n  $scope.$stateParams = $stateParams;\r\n\r\n  // loginService exposed and a new Object containing login user/pwd\r\n  $scope.ls = loginService;\r\n  $scope.login = {\r\n    working: false,\r\n    wrong: false\r\n  };\r\n  $scope.loginMe = function () {\r\n    // setup promise, and 'working' flag\r\n    var loginPromise = $http.post('/login', $scope.login);\r\n    $scope.login.working = true;\r\n    $scope.login.wrong = false;\r\n\r\n    loginService.loginUser(loginPromise);\r\n    loginPromise.error(function () {\r\n      $scope.login.wrong = true;\r\n      $timeout(function () { $scope.login.wrong = false; }, 8000);\r\n    });\r\n    loginPromise.finally(function () {\r\n      $scope.login.working = false;\r\n    });\r\n  };\r\n  $scope.logoutMe = function () {\r\n    loginService.logoutUser($http.get('/logout'));\r\n  };\r\n});\r\n",
    "angular.module('angular-login.directives', [])\r\n/**\r\n * Simple directive to check password equality\r\n *\r\n * usage:\r\n * <input type=\"password\" ng-model=\"password\" password-match=\"password2\">\r\n * <input type=\"password\" ng-model=\"password2\">\r\n */\r\n.directive('passwordMatch', function () {\r\n  return {\r\n    restrict: 'A',\r\n    scope: false,\r\n    require: 'ngModel',\r\n    link: function (scope, elem, attrs, controller) {\r\n      var checker = function () {\r\n        // get the value of the first password\r\n        var pwd = scope.$eval(attrs.ngModel);\r\n        // get the value of the other password\r\n        var pwd2 = scope.$eval(attrs.passwordMatch);\r\n        return pwd === pwd2;\r\n      };\r\n      scope.$watch(checker, function (pwdMatch) {\r\n        controller.$setValidity('match', pwdMatch);\r\n      });\r\n    }\r\n  };\r\n})\r\n/**\r\n * Directive to manage valid/invalid states of remote-validated Data.\r\n * It stores an internal array of values declared invalid by the server.\r\n * Generates the form error specified in case the user re-types the same invalid values,\r\n * clears the errors in case the user changes the ngModel.\r\n *\r\n * usage:\r\n * <input type=\"email\" ng-model=\"email\" remote-validated=\"used\">\r\n *\r\n * NOTE: Your controllers have to make the field invalid in case *your* server says so.\r\n */\r\n.directive('remoteValidated', function () {\r\n  return {\r\n    restrict: 'A',\r\n    scope: false,\r\n    require: 'ngModel',\r\n    link: function (scope, elem, attrs, controller) {\r\n      var invalidItems = [];\r\n      scope.$watch(attrs.ngModel, function (newValue, oldValue) {\r\n        if (newValue) {\r\n          // Check the array of already-bad items\r\n          if (invalidItems.indexOf(newValue) !== -1) {\r\n            return controller.$setValidity(attrs.remoteValidated, false);\r\n          }\r\n          // When the model changes, it checks if the previous value was\r\n          // triggering the error from server-side\r\n          if (controller.$error[attrs.remoteValidated]) {\r\n            invalidItems.push(oldValue);\r\n          }\r\n          controller.$setValidity(attrs.remoteValidated, true);\r\n        }\r\n      });\r\n    }\r\n  };\r\n});\r\n",
    "angular.module('angular-login.error', ['angular-login.grandfather'])\r\n.config(function ($stateProvider) {\r\n  $stateProvider\r\n    .state('app.error', {\r\n      url: '/error/:error',\r\n      templateUrl: 'error/error.tpl.html',\r\n      accessLevel: accessLevels.public\r\n    });\r\n});\r\n",
    "angular.module('angular-login.grandfather', ['ui.router', 'templates-app'])\r\n.config(function ($stateProvider) {\r\n  $stateProvider\r\n    .state('app', {\r\n      abstract: true,\r\n      template: '<ui-view></ui-view>',\r\n      resolve: {\r\n        'login': function (loginService, $q, $http) {\r\n          var roleDefined = $q.defer();\r\n\r\n          /**\r\n           * In case there is a pendingStateChange means the user requested a $state,\r\n           * but we don't know yet user's userRole.\r\n           *\r\n           * Calling resolvePendingState makes the loginService retrieve his userRole remotely.\r\n           */\r\n          if (loginService.pendingStateChange) {\r\n            return loginService.resolvePendingState($http.get('/user'));\r\n          } else {\r\n            roleDefined.resolve();\r\n          }\r\n          return roleDefined.promise;\r\n        }\r\n      }\r\n    });\r\n});\r\n",
    "angular.module('angular-login.home', ['angular-login.grandfather'])\r\n.config(function ($stateProvider) {\r\n  $stateProvider\r\n    .state('app.home', {\r\n      url: '/',\r\n      templateUrl: 'home/home.tpl.html',\r\n      controller: 'HomeController'\r\n    });\r\n})\r\n.controller('HomeController', function ($scope) {\r\n  $scope.users = angular.fromJson(localStorage.getItem('userStorage'));\r\n});\r\n",
    "angular.module('loginService', ['ui.router'])\r\n.provider('loginService', function () {\r\n  var userToken = localStorage.getItem('userToken'),\r\n      errorState = 'app.error',\r\n      logoutState = 'app.home';\r\n\r\n  this.$get = function ($rootScope, $http, $q, $state) {\r\n\r\n    /**\r\n     * Low-level, private functions.\r\n     */\r\n    var setHeaders = function (token) {\r\n      if (!token) {\r\n        delete $http.defaults.headers.common['X-Token'];\r\n        return;\r\n      }\r\n      $http.defaults.headers.common['X-Token'] = token.toString();\r\n    };\r\n\r\n    var setToken = function (token) {\r\n      if (!token) {\r\n        localStorage.removeItem('userToken');\r\n      } else {\r\n        localStorage.setItem('userToken', token);\r\n      }\r\n      setHeaders(token);\r\n    };\r\n\r\n    var getLoginData = function () {\r\n      if (userToken) {\r\n        setHeaders(userToken);\r\n      } else {\r\n        wrappedService.userRole = userRoles.public;\r\n        wrappedService.isLogged = false;\r\n        wrappedService.doneLoading = true;\r\n      }\r\n    };\r\n\r\n    var managePermissions = function () {\r\n      // Register routing function.\r\n      $rootScope.$on('$stateChangeStart', function (event, to, toParams, from, fromParams) {\r\n\r\n        /**\r\n         * $stateChangeStart is a synchronous check to the accessLevels property\r\n         * if it's not set, it will setup a pendingStateChange and will let\r\n         * the grandfather resolve do his job.\r\n         *\r\n         * In short:\r\n         * If accessLevels is still undefined, it let the user change the state.\r\n         * Grandfather.resolve will either let the user in or reject the promise later!\r\n         */\r\n        if (wrappedService.userRole === null) {\r\n          wrappedService.doneLoading = false;\r\n          wrappedService.pendingStateChange = {\r\n            to: to,\r\n            toParams: toParams\r\n          };\r\n          return;\r\n        }\r\n\r\n        // if the state has undefined accessLevel, anyone can access it.\r\n        // NOTE: if `wrappedService.userRole === undefined` means the service still doesn't know the user role,\r\n        // we need to rely on grandfather resolve, so we let the stateChange success, for now.\r\n        if (to.accessLevel === undefined || to.accessLevel.bitMask & wrappedService.userRole.bitMask) {\r\n          angular.noop(); // requested state can be transitioned to.\r\n        } else {\r\n          event.preventDefault();\r\n          $rootScope.$emit('$statePermissionError');\r\n          $state.go(errorState, { error: 'unauthorized' }, { location: false, inherit: false });\r\n        }\r\n      });\r\n\r\n      /**\r\n       * Gets triggered when a resolve isn't fulfilled\r\n       * NOTE: when the user doesn't have required permissions for a state, this event\r\n       *       it's not triggered.\r\n       *\r\n       * In order to redirect to the desired state, the $http status code gets parsed.\r\n       * If it's an HTTP code (ex: 403), could be prefixed with a string (ex: resolvename403),\r\n       * to handle same status codes for different resolve(s).\r\n       * This is defined inside $state.redirectMap.\r\n       */\r\n      $rootScope.$on('$stateChangeError', function (event, to, toParams, from, fromParams, error) {\r\n        /**\r\n         * This is a very clever way to implement failure redirection.\r\n         * You can use the value of redirectMap, based on the value of the rejection\r\n         * So you can setup DIFFERENT redirections based on different promise errors.\r\n         */\r\n        var errorObj, redirectObj;\r\n        // in case the promise given to resolve function is an $http request\r\n        // the error is a object containing the error and additional informations\r\n        error = (typeof error === 'object') ? error.status.toString() : error;\r\n        // in case of a random 4xx/5xx status code from server, user gets loggedout\r\n        // otherwise it *might* forever loop (look call diagram)\r\n        if (/^[45]\\d{2}$/.test(error)) {\r\n          wrappedService.logoutUser();\r\n        }\r\n        /**\r\n         * Generic redirect handling.\r\n         * If a state transition has been prevented and it's not one of the 2 above errors, means it's a\r\n         * custom error in your application.\r\n         *\r\n         * redirectMap should be defined in the $state(s) that can generate transition errors.\r\n         */\r\n        if (angular.isDefined(to.redirectMap) && angular.isDefined(to.redirectMap[error])) {\r\n          if (typeof to.redirectMap[error] === 'string') {\r\n            return $state.go(to.redirectMap[error], { error: error }, { location: false, inherit: false });\r\n          } else if (typeof to.redirectMap[error] === 'object') {\r\n            redirectObj = to.redirectMap[error];\r\n            return $state.go(redirectObj.state, { error: redirectObj.prefix + error }, { location: false, inherit: false });\r\n          }\r\n        }\r\n        return $state.go(errorState, { error: error }, { location: false, inherit: false });\r\n      });\r\n    };\r\n\r\n    /**\r\n     * High level, public methods\r\n     */\r\n    var wrappedService = {\r\n      loginHandler: function (user, status, headers, config) {\r\n        /**\r\n         * Custom logic to manually set userRole goes here\r\n         *\r\n         * Commented example shows an userObj coming with a 'completed'\r\n         * property defining if the user has completed his registration process,\r\n         * validating his/her email or not.\r\n         *\r\n         * EXAMPLE:\r\n         * if (user.hasValidatedEmail) {\r\n         *   wrappedService.userRole = userRoles.registered;\r\n         * } else {\r\n         *   wrappedService.userRole = userRoles.invalidEmail;\r\n         *   $state.go('app.nagscreen');\r\n         * }\r\n         */\r\n        // setup token\r\n        setToken(user.token);\r\n        // update user\r\n        angular.extend(wrappedService.user, user);\r\n        // flag true on isLogged\r\n        wrappedService.isLogged = true;\r\n        // update userRole\r\n        wrappedService.userRole = user.userRole;\r\n        return user;\r\n      },\r\n      loginUser: function (httpPromise) {\r\n        httpPromise.success(this.loginHandler);\r\n      },\r\n      logoutUser: function (httpPromise) {\r\n        /**\r\n         * De-registers the userToken remotely\r\n         * then clears the loginService as it was on startup\r\n         */\r\n        setToken(null);\r\n        this.userRole = userRoles.public;\r\n        this.user = {};\r\n        this.isLogged = false;\r\n        $state.go(logoutState);\r\n      },\r\n      resolvePendingState: function (httpPromise) {\r\n        var checkUser = $q.defer(),\r\n            self = this,\r\n            pendingState = self.pendingStateChange;\r\n\r\n        // When the $http is done, we register the http result into loginHandler, `data` parameter goes into loginService.loginHandler\r\n        httpPromise.success(self.loginHandler);\r\n\r\n        httpPromise.then(\r\n          function success(httpObj) {\r\n            self.doneLoading = true;\r\n            // duplicated logic from $stateChangeStart, slightly different, now we surely have the userRole informations.\r\n            if (pendingState.to.accessLevel === undefined || pendingState.to.accessLevel.bitMask & self.userRole.bitMask) {\r\n              checkUser.resolve();\r\n            } else {\r\n              checkUser.reject('unauthorized');\r\n            }\r\n          },\r\n          function reject(httpObj) {\r\n            checkUser.reject(httpObj.status.toString());\r\n          }\r\n        );\r\n        /**\r\n         * I setted up the state change inside the promises success/error,\r\n         * so i can safely assign pendingStateChange back to null.\r\n         */\r\n        self.pendingStateChange = null;\r\n        return checkUser.promise;\r\n      },\r\n      /**\r\n       * Public properties\r\n       */\r\n      userRole: null,\r\n      user: {},\r\n      isLogged: null,\r\n      pendingStateChange: null,\r\n      doneLoading: null\r\n    };\r\n\r\n    getLoginData();\r\n    managePermissions();\r\n\r\n    return wrappedService;\r\n  };\r\n});\r\n",
    "/* jshint -W084 */\r\nangular.module('angular-login.mock', ['ngMockE2E'])\r\n.factory('delayHTTP', function ($q, $timeout) {\r\n  return {\r\n    request: function (request) {\r\n      var delayedResponse = $q.defer();\r\n      $timeout(function () {\r\n        delayedResponse.resolve(request);\r\n      }, 700);\r\n      return delayedResponse.promise;\r\n    },\r\n    response: function (response) {\r\n      var deferResponse = $q.defer();\r\n\r\n      if (response.config.timeout && response.config.timeout.then) {\r\n        response.config.timeout.then(function () {\r\n          deferResponse.reject();\r\n        });\r\n      } else {\r\n        deferResponse.resolve(response);\r\n      }\r\n\r\n      return $timeout(function () {\r\n        deferResponse.resolve(response);\r\n        return deferResponse.promise;\r\n      });\r\n    }\r\n  };\r\n})\r\n// delay HTTP\r\n.config(['$httpProvider', function ($httpProvider) {\r\n  $httpProvider.interceptors.push('delayHTTP');\r\n}])\r\n.constant('loginExampleData', {\r\n  version: '0.2.0'\r\n})\r\n.run(function ($httpBackend, $log, loginExampleData) {\r\n  var userStorage = angular.fromJson(localStorage.getItem('userStorage')),\r\n      emailStorage = angular.fromJson(localStorage.getItem('emailStorage')),\r\n      tokenStorage = angular.fromJson(localStorage.getItem('tokenStorage')) || {},\r\n      loginExample = angular.fromJson(localStorage.getItem('loginExample'));\r\n\r\n  // Check and corrects old localStorage values, backward-compatibility!\r\n  if (!loginExample || loginExample.version !== loginExampleData.version) {\r\n    userStorage = null;\r\n    tokenStorage = {};\r\n    localStorage.setItem('loginExample', angular.toJson(loginExampleData));\r\n  }\r\n\r\n  if (userStorage === null || emailStorage === null) {\r\n    userStorage = {\r\n      'johnm': { name: 'John', username: 'johnm', password: 'hello', email: 'john.dott@myemail.com', userRole: userRoles.user, tokens: [] },\r\n      'sandrab': { name: 'Sandra', username: 'sandrab', password: 'world', email: 'bitter.s@provider.com', userRole: userRoles.admin, tokens: [] }\r\n    };\r\n    emailStorage = {\r\n      'john.dott@myemail.com': 'johnm',\r\n      'bitter.s@provider.com': 'sandrab'\r\n    };\r\n    localStorage.setItem('userStorage', angular.toJson(userStorage));\r\n    localStorage.setItem('emailStorage', angular.toJson(emailStorage));\r\n  }\r\n\r\n  /**\r\n   * Generates random Token\r\n   */\r\n  var randomUUID = function () {\r\n    var charSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\r\n    var randomToken = '';\r\n    for (var i = 0; i < 36; i++) {\r\n      if (i === 8 || i === 13 || i === 18 || i === 23) {\r\n        randomToken += '';\r\n        continue;\r\n      }\r\n      var randomPoz = Math.floor(Math.random() * charSet.length);\r\n      randomToken += charSet.substring(randomPoz, randomPoz + 1);\r\n    }\r\n    return randomToken;\r\n  };\r\n\r\n  // fakeLogin\r\n  $httpBackend.when('POST', '/login').respond(function (method, url, data, headers) {\r\n    var postData = angular.fromJson(data),\r\n        user = userStorage[postData.username],\r\n        newToken,\r\n        tokenObj;\r\n    $log.info(method, '->', url);\r\n\r\n    if (angular.isDefined(user) && user.password === postData.password) {\r\n      newToken = randomUUID();\r\n      user.tokens.push(newToken);\r\n      tokenStorage[newToken] = postData.username;\r\n      localStorage.setItem('userStorage', angular.toJson(userStorage));\r\n      localStorage.setItem('tokenStorage', angular.toJson(tokenStorage));\r\n      return [200, { name: user.name, userRole: user.userRole, token: newToken }, {}];\r\n    } else {\r\n      return [401, 'wrong combination username/password', {}];\r\n    }\r\n  });\r\n\r\n  // fakeLogout\r\n  $httpBackend.when('GET', '/logout').respond(function (method, url, data, headers) {\r\n    var queryToken, userTokens;\r\n    $log.info(method, '->', url);\r\n\r\n    if (queryToken = headers['X-Token']) {\r\n      if (angular.isDefined(tokenStorage[queryToken])) {\r\n        userTokens = userStorage[tokenStorage[queryToken]].tokens;\r\n        // Update userStorage AND tokenStorage\r\n        userTokens.splice(userTokens.indexOf(queryToken));\r\n        delete tokenStorage[queryToken];\r\n        localStorage.setItem('userStorage', angular.toJson(userStorage));\r\n        localStorage.setItem('tokenStorage', angular.toJson(tokenStorage));\r\n        return [200, {}, {}];\r\n      } else {\r\n        return [401, 'auth token invalid or expired', {}];\r\n      }\r\n    } else {\r\n      return [401, 'auth token invalid or expired', {}];\r\n    }\r\n  });\r\n\r\n  // fakeUser\r\n  $httpBackend.when('GET', '/user').respond(function (method, url, data, headers) {\r\n    var queryToken, userObject;\r\n    $log.info(method, '->', url);\r\n\r\n    // if is present in a registered users array.\r\n    if (queryToken = headers['X-Token']) {\r\n      if (angular.isDefined(tokenStorage[queryToken])) {\r\n        userObject = userStorage[tokenStorage[queryToken]];\r\n        return [200, { token: queryToken, name: userObject.name, userRole: userObject.userRole }, {}];\r\n      } else {\r\n        return [401, 'auth token invalid or expired', {}];\r\n      }\r\n    } else {\r\n      return [401, 'auth token invalid or expired', {}];\r\n    }\r\n  });\r\n\r\n  // fakeRegister\r\n  $httpBackend.when('POST', '/user').respond(function (method, url, data, headers) {\r\n    var postData = angular.fromJson(data),\r\n        newUser,\r\n        errors = [];\r\n    $log.info(method, '->', url);\r\n\r\n    if (angular.isDefined(userStorage[postData.username])) {\r\n      errors.push({ field: 'username', name: 'used' });\r\n    }\r\n\r\n    if (angular.isDefined(emailStorage[postData.email])) {\r\n      errors.push({ field: 'email', name: 'used' });\r\n    }\r\n\r\n    if (errors.length) {\r\n      return [409, {\r\n        valid: false,\r\n        errors: errors\r\n      }, {}];\r\n    } else {\r\n      newUser = angular.extend(postData, { userRole: userRoles[postData.role], tokens: [] });\r\n      delete newUser.role;\r\n\r\n      userStorage[newUser.username] = newUser;\r\n      emailStorage[newUser.email] = newUser.username;\r\n      localStorage.setItem('userStorage', angular.toJson(userStorage));\r\n      localStorage.setItem('emailStorage', angular.toJson(emailStorage));\r\n      return [201, { valid: true, creationDate: Date.now() }, {}];\r\n    }\r\n  });\r\n\r\n});\r\n",
    "angular.module('angular-login.pages', ['angular-login.grandfather'])\r\n.config(function ($stateProvider) {\r\n  $stateProvider\r\n    .state('app.admin', {\r\n      url: '/admin',\r\n      templateUrl: 'pages/admin.tpl.html',\r\n      accessLevel: accessLevels.admin\r\n    })\r\n    .state('app.user', {\r\n      url: '/user',\r\n      templateUrl: 'pages/user.tpl.html',\r\n      accessLevel: accessLevels.user\r\n    });\r\n});\r\n",
    "angular.module('angular-login.register', ['angular-login.grandfather'])\r\n.config(function ($stateProvider) {\r\n  $stateProvider\r\n    .state('app.register', {\r\n      url: '/register',\r\n      templateUrl: 'register/register.tpl.html',\r\n      controller: 'RegisterController',\r\n      accessLevel: accessLevels.anon\r\n    });\r\n})\r\n.controller('RegisterController', function ($scope, $http, $timeout, $state) {\r\n  $scope.xhr = false;\r\n  $scope.redirect = false;\r\n\r\n  $scope.registerObj = {\r\n    role: 'user'\r\n  };\r\n\r\n  $scope.submit = function (formInstance) {\r\n    // xhr is departing\r\n    $scope.xhr = true;\r\n    $http.post('/user', $scope.registerObj)\r\n    .success(function (data, status, headers, config) {\r\n      console.info('post success - ', data);\r\n      $scope.xhr = false;\r\n      $scope.redirect = true;\r\n      $timeout(function () {\r\n        $state.go('app.home');\r\n      }, 2000);\r\n    })\r\n    .error(function (data, status, headers, config) {\r\n      data.errors.forEach(function (error, index, array) {\r\n        formInstance[error.field].$error[error.name] = true;\r\n      });\r\n      formInstance.$setPristine();\r\n      console.info('post error - ', data);\r\n      $scope.xhr = false;\r\n    });\r\n  };\r\n});\r\n",
    "/**\r\n * Directly from fnakstad\r\n * https://github.com/fnakstad/angular-client-side-auth/blob/master/client/js/routingConfig.js\r\n */\r\n\r\n(function (exports) {\r\n\r\n  var config = {\r\n\r\n    /* List all the roles you wish to use in the app\r\n    * You have a max of 31 before the bit shift pushes the accompanying integer out of\r\n    * the memory footprint for an integer\r\n    */\r\n    roles: [\r\n      'public',\r\n      'user',\r\n      'admin'\r\n    ],\r\n\r\n    /*\r\n    Build out all the access levels you want referencing the roles listed above\r\n    You can use the \"*\" symbol to represent access to all roles\r\n     */\r\n    accessLevels: {\r\n      'public' : '*',\r\n      'anon': ['public'],\r\n      'user' : ['user', 'admin'],\r\n      'admin': ['admin']\r\n    }\r\n\r\n  };\r\n\r\n  /*\r\n    Method to build a distinct bit mask for each role\r\n    It starts off with \"1\" and shifts the bit to the left for each element in the\r\n    roles array parameter\r\n   */\r\n  function buildRoles(roles) {\r\n\r\n    var bitMask = \"01\";\r\n    var userRoles = {};\r\n\r\n    for (var role in roles) {\r\n      var intCode = parseInt(bitMask, 2);\r\n      userRoles[roles[role]] = {\r\n        bitMask: intCode,\r\n        title: roles[role]\r\n      };\r\n      bitMask = (intCode << 1).toString(2);\r\n    }\r\n\r\n    return userRoles;\r\n  }\r\n\r\n  /*\r\n  This method builds access level bit masks based on the accessLevelDeclaration parameter which must\r\n  contain an array for each access level containing the allowed user roles.\r\n   */\r\n  function buildAccessLevels(accessLevelDeclarations, userRoles) {\r\n\r\n    var accessLevels = {},\r\n        resultBitMask,\r\n        role;\r\n    for (var level in accessLevelDeclarations) {\r\n\r\n      if (typeof accessLevelDeclarations[level] === 'string') {\r\n        if (accessLevelDeclarations[level] === '*') {\r\n\r\n          resultBitMask = '';\r\n\r\n          for (role in userRoles) {\r\n            resultBitMask += \"1\";\r\n          }\r\n          //accessLevels[level] = parseInt(resultBitMask, 2);\r\n          accessLevels[level] = {\r\n            bitMask: parseInt(resultBitMask, 2),\r\n            title: accessLevelDeclarations[level]\r\n          };\r\n        }\r\n        else {\r\n          console.log(\"Access Control Error: Could not parse '\" + accessLevelDeclarations[level] + \"' as access definition for level '\" + level + \"'\");\r\n        }\r\n      }\r\n      else {\r\n\r\n        resultBitMask = 0;\r\n        for (role in accessLevelDeclarations[level]) {\r\n          if (userRoles.hasOwnProperty(accessLevelDeclarations[level][role])) {\r\n            resultBitMask = resultBitMask | userRoles[accessLevelDeclarations[level][role]].bitMask;\r\n          }\r\n          else {\r\n            console.log(\"Access Control Error: Could not find role '\" + accessLevelDeclarations[level][role] + \"' in registered roles while building access for '\" + level + \"'\");\r\n          }\r\n        }\r\n        accessLevels[level] = {\r\n          bitMask: resultBitMask,\r\n          title: accessLevelDeclarations[level][role]\r\n        };\r\n      }\r\n    }\r\n\r\n    return accessLevels;\r\n  }\r\n\r\n\r\n  exports.userRoles = buildRoles(config.roles);\r\n  exports.accessLevels = buildAccessLevels(config.accessLevels, exports.userRoles);\r\n\r\n})(typeof exports === 'undefined' ? this : exports);\r\n"
  ]
}